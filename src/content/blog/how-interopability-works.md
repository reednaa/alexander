---
title: How are Interopability Protocols Built?
author: Alexander Lindgren
pubDatetime: 2024-10-14T16:00:00+02:00
slug: how-interopability-work
featured: false
draft: false
tags:
  - interopability
  - wormhole
  - layerzero
  - hyperlane
description:
  We shall explore how various messaging protocols – Wormhole, Hyperlane, and Layerzero – sends messages and compare their complexity. You may be surprised at how simple or complicated it can be made.
---
Ever wondered what messaging protocols look like on-chain? Let's examine [Wormhole](https://wormhole.com), [LayerZero](https://layerzero.network/), and [Hyperlane](hyperlane.xyz) to discover how to send & receive cross-chain messages and what is required to make it happen.

## Wormhole

The simplest messaging protocol with 1 massive contract that has been assigned the task of everything, fittingly called [`Implementation.sol`](https://github.com/wormhole-foundation/wormhole/blob/a0dd60f8a0e4b9cfe26593c379d25eaf9f73c43c/ethereum/contracts/Implementation.sol). It implements 3 key features:

1. A list of the current approved Guardians along with a governance structure. (inherited through [`Governance.sol`](https://github.com/wormhole-foundation/wormhole/blob/a0dd60f8a0e4b9cfe26593c379d25eaf9f73c43c/ethereum/contracts/Governance.sol)) 
2. The `publishMessage()` endpoint that allows someone to send messages (inherited through [`implementation.sol`](https://github.com/wormhole-foundation/wormhole/blob/a0dd60f8a0e4b9cfe26593c379d25eaf9f73c43c/ethereum/contracts/Implementation.sol#L15))
3. And lastly, the logic to verify messages. (inside [`Messages.sol`](https://github.com/wormhole-foundation/wormhole/blob/a0dd60f8a0e4b9cfe26593c379d25eaf9f73c43c/ethereum/contracts/Messages.sol)).

To send a message with Wormhole, first call [`messageFee()`](https://github.com/wormhole-foundation/wormhole/blob/a0dd60f8a0e4b9cfe26593c379d25eaf9f73c43c/ethereum/contracts/Getters.sol#L49) to get the fee. Then call [`publishMessage{value: messageFee()}(…)`](https://github.com/wormhole-foundation/wormhole/blob/a0dd60f8a0e4b9cfe26593c379d25eaf9f73c43c/ethereum/contracts/Implementation.sol#L15-L26) to send the message. On `publishMessage` you specify an optional nonce (for your contract), your message, and a `consistencyLevel`. `publishMessage` emits a message log and then returns a unique sequence number to you. Notice that you don’t specify a chain. This is because Wormhole messages are broadcast. A Wormhole message can be verified everywhere. It is the caller’s job to encode some kind of restricting logic.

Once the message is considered <u>final</u> as by the included consistency level – which can be set to anything from 1 confirmation to <u>final</u> – your message will get signed and becomes available to pickup in the gossip network. It can then be verified by calling [`parseAndVerifyVM`](https://github.com/wormhole-foundation/wormhole/blob/a0dd60f8a0e4b9cfe26593c379d25eaf9f73c43c/ethereum/contracts/Messages.sol#L16) on the destination chain., the signatures are extracted and compared against the hash of the message. 

Notice that this implementation has no relaying logic or on-chain storage usage. It is pure: Sending a message is done by emitting an event on their contract, and verifying it is done by comparing the configured guardians against the signatures. The best part about this structure is that if you wanted, you can ignore everything but the `publishMessage` call. You can copy `parseAndVerifyVM` into your own contract, choose your own relayers, implement your own relayer scheme. You can even implement `parseAndVerifyVM` on a chain not supported by Wormhole!

## Hyperlane

As I have previously written, Hyperlane supports a wide range of verification pathways. As a result, their complexity can range from almost trivial to very complex. However, they have done a stellar job at abstracting as much of this logic such that the implementation remain fairly straight forward.  For simplicity, let's focus on their *core* product: [Multisig ISM](https://docs.hyperlane.xyz/docs/protocol/ISM/multisig-ISM). [ISM means Interchain Security Modules](https://docs.hyperlane.xyz/docs/protocol/ISM/modular-security) and is what Hyperlane uses to describe security models. This allows them to essentially collect all the other messaging protocols, which I have previously described as a [Zoo](/posts/interopability-experiences/#:~:text=Hyperlane%20is%20a%20zoo). Instead of 1 big contract, logic is delegated to smaller contracts:

- [`Mailbox.sol`](https://github.com/hyperlane-xyz/hyperlane-monorepo/blob/main/solidity/contracts/Mailbox.sol) is the main interface contract and implement handlers to handle message execution regardless of the security model. Importantly:
    - The [`dispatch()`](https://github.com/hyperlane-xyz/hyperlane-monorepo/blob/a4d5d692f3e8230cfbf2b87ac5e2775fe3da8bb9/solidity/contracts/Mailbox.sol#L276) endpoint that allows someone to send messages, and call relevant hooks.
    - The [`process()`](https://github.com/hyperlane-xyz/hyperlane-monorepo/blob/a4d5d692f3e8230cfbf2b87ac5e2775fe3da8bb9/solidity/contracts/Mailbox.sol#L201) endpoint to verify incoming messages ()
    - Logic to read config from the recipient(!).
- [Various](https://github.com/hyperlane-xyz/hyperlane-monorepo/tree/470e53bb76834ea1390edf28800bdd02a5d5a7c0/solidity/contracts/hooks) [hooks](https://github.com/hyperlane-xyz/hyperlane-monorepo/blob/470e53bb76834ea1390edf28800bdd02a5d5a7c0/solidity/contracts/Mailbox.sol#L310-L311) are used to manage fees & relaying.
- [External ISMs](https://github.com/hyperlane-xyz/hyperlane-monorepo/tree/470e53bb76834ea1390edf28800bdd02a5d5a7c0/solidity/contracts/isms) are used to [verify](https://github.com/hyperlane-xyz/hyperlane-monorepo/blob/470e53bb76834ea1390edf28800bdd02a5d5a7c0/solidity/contracts/Mailbox.sol#L235) the authenticity of messages.

Assuming you want to use default settings, sending a message requires calling [`quoteDispatch(...)`](https://github.com/hyperlane-xyz/hyperlane-monorepo/blob/a4d5d692f3e8230cfbf2b87ac5e2775fe3da8bb9/solidity/contracts/Mailbox.sol#L325) to get the fee and then [`dispatch()`](https://github.com/hyperlane-xyz/hyperlane-monorepo/blob/470e53bb76834ea1390edf28800bdd02a5d5a7c0/solidity/contracts/Mailbox.sol#L276-L314). On this call you specify: the destination chain, the destination recipient, and the message. Optionally, you can also specify hook metadata like [InterchainGasPaymaster](https://github.com/hyperlane-xyz/hyperlane-monorepo/blob/main/solidity/contracts/hooks/igp/InterchainGasPaymaster.sol) to pay for relaying. Hyperlane allows for a significantly increased customization at the cost of simplicity, though at no point does it get out of hand. Additionally, it is expected that a system which has built in support to pay for relaying is slightly more complex than one without. 

Hyperlane uses signed checkpoints to verify messages, designed such that any later signing checkpoint also signs previous checkpoints. Once a checkpoint has been signed, all message inside it and all previous messages can be verified. The Hyperlane Mailbox calls [`verify(...)`](https://github.com/hyperlane-xyz/hyperlane-monorepo/blob/470e53bb76834ea1390edf28800bdd02a5d5a7c0/solidity/contracts/isms/multisig/AbstractMultisigIsm.sol#L98-L126) on the ISM contract. 

Since message verification happens outside the mailbox with no on-chain commitments. You can in theory call [`ism.verify`](https://github.com/hyperlane-xyz/hyperlane-monorepo/blob/470e53bb76834ea1390edf28800bdd02a5d5a7c0/solidity/contracts/Mailbox.sol#L235) yourself to avoid interacting with the Mailbox or even implement the associated logic yourself. Additionally, the destination field is only enforced in [1 line of code](https://github.com/hyperlane-xyz/hyperlane-monorepo/blob/a4d5d692f3e8230cfbf2b87ac5e2775fe3da8bb9/solidity/contracts/Mailbox.sol#L209-L212) so if you wanted, you could in theory move the [`process`](https://github.com/hyperlane-xyz/hyperlane-monorepo/blob/470e53bb76834ea1390edf28800bdd02a5d5a7c0/solidity/contracts/Mailbox.sol#L201-L245) (and/or the multisig ISM `verify`) logic to your contract and get the ability to broadcast messages like Wormhole. (Though you need to keep track of the validators yourself).

Config for hyperlane messaging is stored on the [recipient](https://github.com/hyperlane-xyz/hyperlane-monorepo/blob/470e53bb76834ea1390edf28800bdd02a5d5a7c0/solidity/contracts/Mailbox.sol#L404-L409), so it doesn’t suffer from an $n^2$ problem where you need to set new configs for every single support chain as you expand to new chains, since you can programmably predict various config settings.



### Finality

After the message is deemed <u>final</u> by validators, they will sign it and make it available to relayers. Unlike Wormhole, Hyperlane doesn’t have the concept of finality levels. That is because the economic security module assumes that all signed checkpoints are <u>final</u> otherwise validators can get slashed. Let's also address the elephant in the room – <u>final</u>. Both Wormhole and Hyperlane allows dApps to set the confidence of inclusion to final. Final by Hyperlane is defined as: When validators deem that their economic security is not at risk of a reorg, where for Wormhole it is slightly more *fluffy*. However, abstracting confirmations & time into a single "final" is helpful for applications, since they can now delegate the concept of finality to messaging protocols that have spent more time to think about it. Kudos to Hyperlane and Wormhole.


## LayerZero

Sending and receiving messages through LayerZero acts is more complicated than both Wormhole and Hyperlane. Considering I am guaranteed to get something wrong, I will focus on the highlights. LayerZero contains 2 main components:

  - [EndpointV2.sol](https://github.com/LayerZero-Labs/LayerZero-v2/blob/main/packages/layerzero-v2/evm/protocol/contracts/EndpointV2.sol) is responsible for message flow: [quoting](https://github.com/LayerZero-Labs/LayerZero-v2/blob/67582d09449a8dabef123dd84c7159f029b98829/packages/layerzero-v2/evm/protocol/contracts/EndpointV2.sol#L55), [sending](https://github.com/LayerZero-Labs/LayerZero-v2/blob/67582d09449a8dabef123dd84c7159f029b98829/packages/layerzero-v2/evm/protocol/contracts/EndpointV2.sol#L83), [verifying](https://github.com/LayerZero-Labs/LayerZero-v2/blob/67582d09449a8dabef123dd84c7159f029b98829/packages/layerzero-v2/evm/protocol/contracts/EndpointV2.sol#L151), and [executing](https://github.com/LayerZero-Labs/LayerZero-v2/blob/67582d09449a8dabef123dd84c7159f029b98829/packages/layerzero-v2/evm/protocol/contracts/EndpointV2.sol#L172). The important function is [`send(...)`](https://github.com/LayerZero-Labs/LayerZero-v2/blob/67582d09449a8dabef123dd84c7159f029b98829/packages/layerzero-v2/evm/protocol/contracts/EndpointV2.sol#L83)
  - [Ultralight Nodes (ULNs)](https://github.com/LayerZero-Labs/LayerZero-v2/tree/main/packages/layerzero-v2/evm/messagelib/contracts) of which there are 2 types: Receive and Send. The send library implements [payments for DVNs](https://github.com/LayerZero-Labs/LayerZero-v2/blob/67582d09449a8dabef123dd84c7159f029b98829/packages/layerzero-v2/evm/messagelib/contracts/uln/SendUlnBase.sol#L32-L56), [payment for the executor](https://github.com/LayerZero-Labs/LayerZero-v2/blob/67582d09449a8dabef123dd84c7159f029b98829/packages/layerzero-v2/evm/messagelib/contracts/uln/SendUlnBase.sol#L58-L87), [send app config](https://github.com/LayerZero-Labs/LayerZero-v2/blob/67582d09449a8dabef123dd84c7159f029b98829/packages/layerzero-v2/evm/messagelib/contracts/uln/uln302/SendUln302.sol#L30-L42). The receive library implements verification logic like [validation submissions](https://github.com/LayerZero-Labs/LayerZero-v2/blob/67582d09449a8dabef123dd84c7159f029b98829/packages/layerzero-v2/evm/messagelib/contracts/uln/ReceiveUlnBase.sol#L43-L46) and [message verification](https://github.com/LayerZero-Labs/LayerZero-v2/blob/67582d09449a8dabef123dd84c7159f029b98829/packages/layerzero-v2/evm/messagelib/contracts/uln/ReceiveUlnBase.sol#L59-L77).
  - Additionally, DVNs are expected to implement a contract to quote the cost to submit message and for them to be paid and relayers – committers & executors – needs to implement a similar contract that accepts and quotes payment for their work.

Before we can begin sending messages with LayerZero, we may want to configure out dApp. Layerzero has a wide set of [available configs](https://docs.layerzero.network/v2/developers/evm/oapp/overview#deployment-workflow:~:text=Set%20the%20DVN%20configuration%2C%20including%20optional%20settings%20such%20as%20block%20confirmations%2C%20security%20threshold%2C%20the%20Executor%2C%20max%20message%20size%2C%20and%20send/receive%20libraries.), significantly more than both Wormhole and Hyperlane combined. You can configure: block confirmations, security threshold, custom receive & send libraries, executor, max message size, and DVN set. Additionally, when sending the fee currency – LZ token or gas – can be configured. For each chain you are deployed on, you need to set the config for that chain specifically. Luckily, LZ does allow [an array of configurations](https://github.com/LayerZero-Labs/LayerZero-v2/blob/67582d09449a8dabef123dd84c7159f029b98829/packages/layerzero-v2/evm/messagelib/contracts/uln/uln302/SendUln302.sol#L31) in a single call. However, once you add a new chain to your existing 20 chains, you need to configure that new chain for your 20 other deployments.

To send a message, you need to call [`quote(...)`](https://github.com/LayerZero-Labs/LayerZero-v2/blob/67582d09449a8dabef123dd84c7159f029b98829/packages/layerzero-v2/evm/protocol/contracts/EndpointV2.sol#L55) to get the fee estimation and then call [`send(...)`](https://github.com/LayerZero-Labs/LayerZero-v2/blob/67582d09449a8dabef123dd84c7159f029b98829/packages/layerzero-v2/evm/protocol/contracts/EndpointV2.sol#L83C14-L83C18) with the fee. For both Wormhole & Hyperlane this fee doesn’t change very often (ignoring relayer fees), however, for Layerzero you need to pay DVNs (either LZ or — god forbid if you are deployed to many chains — your configured DVNs) to submit message validations on the remote chain. They do this by calling [`verify(...)`](https://github.com/LayerZero-Labs/LayerZero-v2/blob/67582d09449a8dabef123dd84c7159f029b98829/packages/layerzero-v2/evm/messagelib/contracts/uln/ReceiveUlnBase.sol#L43-L46) on the receive library on the remote chain. Each and every message send with LZ needs to have every single DVN call `verify`.

Once the configured DVNs have all called `verify` (after your configured number of confirmations) the [`verifiable(...)`](https://github.com/LayerZero-Labs/LayerZero-v2/blob/67582d09449a8dabef123dd84c7159f029b98829/packages/layerzero-v2/evm/messagelib/contracts/uln/ReceiveUlnBase.sol#L29-L35) function will return `true` for the message and the committer can call [`verify`](https://github.com/LayerZero-Labs/LayerZero-v2/blob/67582d09449a8dabef123dd84c7159f029b98829/packages/layerzero-v2/evm/protocol/contracts/EndpointV2.sol#L151) on the Endpoint. This [deletes](https://github.com/LayerZero-Labs/LayerZero-v2/blob/67582d09449a8dabef123dd84c7159f029b98829/packages/layerzero-v2/evm/messagelib/contracts/uln/ReceiveUlnBase.sol#L67) the proof inside the receive library and [stores it](https://github.com/LayerZero-Labs/LayerZero-v2/blob/67582d09449a8dabef123dd84c7159f029b98829/packages/layerzero-v2/evm/protocol/contracts/MessagingChannel.sol#L45) in the endpoint. Then [`lzReceive`](https://github.com/LayerZero-Labs/LayerZero-v2/blob/67582d09449a8dabef123dd84c7159f029b98829/packages/layerzero-v2/evm/protocol/contracts/EndpointV2.sol#L172) can be called which [deletes](https://github.com/LayerZero-Labs/LayerZero-v2/blob/67582d09449a8dabef123dd84c7159f029b98829/packages/layerzero-v2/evm/protocol/contracts/MessagingChannel.sol#L150) the proof from the endpoint, increments a lazy nonce (to allow previously verified messages with lower nonces to be executed), and calls the [receiver](https://github.com/LayerZero-Labs/LayerZero-v2/blob/67582d09449a8dabef123dd84c7159f029b98829/packages/layerzero-v2/evm/protocol/contracts/EndpointV2.sol#L181).

Unlike both Hyperlane and Wormhole, Layerzero has no concept of finality. They have some default confirmation recommendations, but that is it. Once the configured number of confirmations have been reached, DVNs will submit it.

With LayerZero having so much on-chain logic – paying DVNs, DVNs submitting proofs, moving verifications from the receive library into the endpoint, calling verify and then lzReceive, paying the executor, and along the way quoting every single entity – uses a lot of gas. Based on our testing, sending a LayerZero somtimes costs twice that of the same Wormhole message. Using LayerZero instead of Wormhole for @CatalystAMM make a swap — in its entirety — 40% more expensive.


Indeed, I am actually ignoring some stuff here: DVNs configs, gas price feeds, message configuration, message limits, allow lists, and message nonces & order. Everything I have praised either Wormhole or Hyperlane for: simplicity, no on-chain message commits, flexible message verification, placing configuration inside the sender or recipient, ability to set finality levels instead of just confirmations, lightweight protocol, few important contracts, and relayer flexibility. If you have noticed, I have linked to every single function called. LayerZero's contracts are split across 2 projects and many Solidity files. Both Wormhole and Hyperlane's repository structures are way simpler. LayerZero is spaghetti.